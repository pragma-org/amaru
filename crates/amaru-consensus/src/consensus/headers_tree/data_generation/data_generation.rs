// Copyright 2025 PRAGMA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::consensus::headers_tree::data_generation::TestHeader;
use crate::consensus::headers_tree::HeadersTree;
use amaru_kernel::peer::Peer;
use amaru_kernel::HEADER_HASH_SIZE;
use amaru_ouroboros_traits::IsHeader;
use pallas_crypto::hash::Hash;
use proptest::prelude::{any, RngCore, Strategy};
use proptest::prop_compose;
use rand::prelude::StdRng;
use rand::{Rng, SeedableRng};
use rand_distr::{Distribution, Exp};
use std::fmt::Debug;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Tree<H> {
    value: H,
    children: Vec<Tree<H>>,
}

/// Generate a tree of headers
pub fn generate_test_header_tree(
    depth: usize,
    seed: u64,
) -> Tree<TestHeader> {
    let mut rng = StdRng::seed_from_u64(seed);

    let root = generate_test_header(&mut rng);
    let mut root_tree = Tree::make_leaf(&root);
    generate_test_header_subtree(&mut rng, &mut root_tree, depth - 1);
    root_tree.renumber_slots(1);
    root_tree
}

impl Tree<TestHeader> {
    fn renumber_slots(&mut self, start: u64) {
        self.value.slot = start;
        for (i, child) in self.children.iter_mut().enumerate() {
            child.renumber_slots(start + ((i + 1) as u64))
        }
    }
}

impl<H: Clone> Tree<H> {
    fn make_leaf(root: &H) -> Tree<H> {
        Tree { value: root.clone(), children: vec![] }
    }

    fn add_child(&mut self, child: &H) -> &mut Tree<H> {
        self.children.push(Tree::make_leaf(&child));
        self
    }

    fn get_last_child_mut(&mut self) -> Option<&mut Tree<H>> {
        let l = self.children.len();
        self.children.get_mut(l - 1)
    }

    pub fn all_chains(&self) -> Vec<Vec<&H>> {
        let mut result: Vec<Vec<&H>> = vec![];
        for child in self.children.iter() {
            result.extend(child.all_chains().iter().map(|c| {
                let mut start = vec![&self.value];
                start.extend(c);
                start
            }))
        }
        result
    }
}

fn generate_test_header_subtree(
    rng: &mut StdRng,
    tree: &mut Tree<TestHeader>,
    depth: usize,
) {
    let mut spine = generate_headers(depth, rng);
    let mut current = tree;
    let mut current_size = 0;
    for n in spine.iter_mut() {
        current.add_child(n);
        n.parent = Some(current.value.hash());
        current = current.get_last_child_mut().unwrap();
        current_size += 1;
        let other_branch_depth = rng.random_range(0..(depth - current_size + 1));
        if other_branch_depth > 0 {
            generate_test_header_subtree(rng, current, other_branch_depth);
        }
    }
}


/// Generate a chain of headers anchored at a given header.
///
/// The chain is generated by creating headers with random body hash, and linking
/// them to the previous header in the chain until the desired length is reached.
pub fn generate_headers_chain(length: usize) -> Vec<TestHeader> {
    let mut rng = StdRng::seed_from_u64(42);
    generate_headers(length, &mut rng)
}

/// Generate just one header
pub fn generate_header() -> TestHeader {
    generate_headers_chain(1)[0]
}

pub fn create_headers_tree(size: usize) -> (HeadersTree<TestHeader>, Vec<TestHeader>) {
    let headers = generate_headers_chain(size);
    let mut tree = HeadersTree::new(10, &headers.first().cloned());
    let mut tail = headers.clone();
    _ = tail.remove(0);
    _ = tree.insert_headers(&tail);
    (tree, headers)
}

pub fn initialize_with_peer(
    size: usize,
    peer: &Peer,
) -> (HeadersTree<TestHeader>, Vec<TestHeader>) {
    let (mut tree, headers) = create_headers_tree(size);
    let tip = headers.last().unwrap();
    tree.initialize_peer(peer, &tip.hash()).unwrap();
    (tree, headers)
}

pub fn make_header_with_parent(parent: &TestHeader) -> TestHeader {
    TestHeader {
        hash: random_hash(),
        slot: parent.slot + 1,
        parent: Some(parent.hash()),
    }
}

pub fn random_hash() -> Hash<HEADER_HASH_SIZE> {
    Hash::from(random_bytes(HEADER_HASH_SIZE).as_slice())
}

pub fn any_tree_of_headers(
    depth: usize,
) -> impl Strategy<Value=Tree<TestHeader>> {
    (0..u64::MAX).prop_map(move |seed| generate_test_header_tree(depth, seed))
}

// Data generator for random TestHeaders
prop_compose! {
    pub fn any_test_header()(
        slot in 0..1000000u64,
        parent in any::<[u8; 32]>(),
        body in any::<[u8; 32]>(),
    )
        -> TestHeader {
        TestHeader {
            hash: body.into(),
            slot,
            parent: Some(parent.into()),
        }
    }
}

// IMPLEMENTATION

/// Generate a chain of headers anchored at a given header.
///
/// The chain is generated by creating headers with random body hash, and linking
/// them to the previous header in the chain until the desired length is reached.
fn generate_headers(length: usize, rng: &mut StdRng) -> Vec<TestHeader> {
    let mut headers: Vec<TestHeader> = Vec::new();
    let mut parent: Option<TestHeader> = None;
    // simulate block distribution on mainnet as an exponential distribution with parameter Î» = 1/20
    let poi = Exp::new(0.05).unwrap();
    let next_slot: f32 = poi.sample(rng);
    for _ in 0..length {
        let mut header = generate_test_header(rng);
        header.slot = parent.map_or(0, |h| h.slot()) + (next_slot.floor() as u64);
        header.parent = parent.map(|h| h.hash());
        headers.push(header);
        parent = Some(header);
    }
    headers
}

fn generate_test_header(rng: &mut StdRng) -> TestHeader {
    TestHeader {
        hash: Hash::from(random_bytes_with_rng(HEADER_HASH_SIZE, rng).as_slice()),
        slot: 0,
        parent: None,
    }
}

/// Very simple function to generate random sequence of bytes of given length.
fn random_bytes(arg: usize) -> Vec<u8> {
    random_bytes_with_rng(arg, &mut StdRng::from_os_rng())
}

/// Very simple function to generate random sequence of bytes of given length.
fn random_bytes_with_rng(arg: usize, rng: &mut StdRng) -> Vec<u8> {
    let mut buffer = vec![0; arg];
    rng.fill_bytes(&mut buffer);
    buffer
}
