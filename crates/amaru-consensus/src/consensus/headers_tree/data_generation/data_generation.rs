// Copyright 2025 PRAGMA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! This module provides data types and functions to generate data suited to testing the `HeadersTree`:
//!
//!  - `Tree<H>` is used to eventually hold a tree of `BlockHeader`s.
//!  - `generate_header_tree` generates such a tree by arbitrarily grafting subtrees on a chain
//!    of size `depth`.
//!
//!

use crate::consensus::headers_tree::HeadersTree;
use crate::consensus::headers_tree::data_generation::Ratio;
use crate::consensus::headers_tree::tree::Tree;
use amaru_kernel::peer::Peer;
use amaru_kernel::{Bytes, HEADER_HASH_SIZE, Header};
use amaru_ouroboros_traits::in_memory_consensus_store::InMemConsensusStore;
use amaru_ouroboros_traits::tests::make_header;
use amaru_ouroboros_traits::{BlockHeader, ChainStore, HeaderHash, IsHeader};
use proptest::prelude::Strategy;
use rand::prelude::StdRng;
use rand::{Rng, RngCore, SeedableRng};
use rand_distr::{Distribution, Exp};
use std::sync::Arc;

impl Tree<BlockHeader> {
    /// This function is used to give incrementing slot numbers to `BlockHeader`s and help test failures
    /// diagnosis
    fn renumber_slots(&mut self, start: u64) {
        self.value.set_slot(start);
        for (i, child) in self.children.iter_mut().enumerate() {
            // set the parent hash of the child to the current node hash before renumbering
            child.value.set_parent(self.value.hash());
            child.renumber_slots(start + ((i + 1) as u64));
        }
    }
}

/// Return a `proptest` Strategy producing a random `Tree<BlockHeader>` of a given depth
pub fn any_tree_of_headers(
    depth: usize,
    branching_ratio: Ratio,
) -> impl Strategy<Value = Tree<BlockHeader>> {
    (0..u64::MAX).prop_map(move |seed| generate_header_tree(depth, seed, branching_ratio))
}

/// Generate a tree of headers of a given depth.
/// A seed is used to control the random generation of subtrees on top of a spine of length `depth`.
pub fn generate_header_tree(depth: usize, seed: u64, branching_ratio: Ratio) -> Tree<BlockHeader> {
    let mut rng = StdRng::seed_from_u64(seed);

    let root = generate_header(1, 1, None, &mut rng);
    let mut root_tree = Tree::make_leaf(&root);
    generate_header_subtree(&mut rng, &mut root_tree, depth - 1, branching_ratio);
    // renumber slots to make debugging easier
    root_tree.renumber_slots(1);
    root_tree
}

/// Given a random generator and a tree:
///
///  - Generate a spine (a chain of `TestHeaders`).
///  - Randomly add subtrees to nodes of that spine.
///  - Graft the spine on the last child of `tree`.
///
/// The depth is used so that the subtrees added to the spine don't have a higher depth than the spine.
/// The branching ratio is used to control how often subtrees are added to the spine.
///
fn generate_header_subtree(
    rng: &mut StdRng,
    tree: &mut Tree<BlockHeader>,
    depth: usize,
    branching_ratio: Ratio,
) -> Vec<BlockHeader> {
    let mut spine = generate_headers(depth, rng);
    let mut current = tree;
    let mut current_size = 0;
    for n in spine.iter_mut() {
        current.add_child(n);
        n.set_parent(current.value.hash());
        current = current.get_last_child_mut().unwrap();
        current_size += 1;
        let other_branch_depth = rng.random_range(
            0..((depth - current_size) * branching_ratio.0 as usize / branching_ratio.1 as usize
                + 1),
        );
        if other_branch_depth > 0 {
            generate_header_subtree(rng, current, other_branch_depth, branching_ratio);
        }
    }
    spine
}

/// Generate a chain of headers anchored at a given header.
///
/// The chain is generated by creating headers with random body hash, and linking
/// them to the previous header in the chain until the desired length is reached.
pub fn generate_headers_chain(length: usize) -> Vec<BlockHeader> {
    let mut rng = StdRng::seed_from_u64(42);
    generate_headers(length, &mut rng)
}

/// Generate just one header
pub fn generate_single_header() -> BlockHeader {
    generate_headers_chain(1)[0].clone()
}

/// Generate a random `HeadersTree` initialized with a single chain of `BlockHeader`s
pub fn create_headers_tree_with_store(
    store: Arc<dyn ChainStore<BlockHeader>>,
    size: usize,
) -> HeadersTree<BlockHeader> {
    let headers = generate_headers_chain(size);
    for header in &headers {
        store.store_header(header).unwrap();
    }
    store.set_anchor_hash(&headers[0].hash()).unwrap();
    store
        .set_best_chain_hash(&headers[headers.len() - 1].hash())
        .unwrap();
    HeadersTree::new(store.clone(), 10)
}

/// Generate a random `HeadersTree` initialized with a single chain of `BlockHeader`s
pub fn create_headers_tree(size: usize) -> HeadersTree<BlockHeader> {
    create_headers_tree_with_store(Arc::new(InMemConsensusStore::new()), size)
}

/// Generate a `HeadersTree` with one chain and a peer at the tip.
pub fn initialize_with_peer(size: usize, peer: &Peer) -> HeadersTree<BlockHeader> {
    initialize_with_store_and_peer(Arc::new(InMemConsensusStore::new()), size, peer)
}

/// Generate a `HeadersTree` with one chain and a peer at the tip.
pub fn initialize_with_store_and_peer(
    store: Arc<dyn ChainStore<BlockHeader>>,
    size: usize,
    peer: &Peer,
) -> HeadersTree<BlockHeader> {
    let mut tree = create_headers_tree_with_store(store, size);
    tree.initialize_peer(peer, &tree.best_chain_tip().hash())
        .unwrap();
    tree
}

/// Generate a random `BlockHeader`, child of the `parent` one
/// and store it in the provided store.
pub fn store_header_with_parent(
    store: Arc<dyn ChainStore<BlockHeader>>,
    parent: &BlockHeader,
) -> BlockHeader {
    let mut std_rng = StdRng::from_seed([0; 32]);
    let header = generate_header(1, parent.slot() + 1, Some(parent.hash()), &mut std_rng);
    store.store_header(&header).unwrap();
    header
}

// IMPLEMENTATION

/// Generate a chain of headers anchored at a given header.
///
/// The chain is generated by creating headers with random body hash, and linking
/// them to the previous header in the chain until the desired length is reached.
fn generate_headers(length: usize, rng: &mut StdRng) -> Vec<BlockHeader> {
    let mut headers: Vec<BlockHeader> = Vec::new();
    let mut parent: Option<BlockHeader> = None;
    // simulate block distribution on mainnet as an exponential distribution with parameter Î» = 1/20
    let poi = Exp::new(0.05).unwrap();
    let next_slot: f32 = poi.sample(rng);
    for _ in 0..length {
        let slot = parent.clone().map_or(0, |h| h.slot()) + (next_slot.floor() as u64);
        let parent_hash = parent.clone().map(|h| h.hash());
        let header = generate_header(1, slot, parent_hash, rng);
        headers.push(header.clone());
        parent = Some(header);
    }
    headers
}

/// Generate a single `BlockHeader` but using the provided random generator.
fn generate_header(
    block: u64,
    slot: u64,
    parent: Option<HeaderHash>,
    rng: &mut StdRng,
) -> BlockHeader {
    let mut header: Header = make_header(block, slot, parent);
    // introduce some randomness in the header so that the hash is not predictable
    header.body_signature = Bytes::from(random_bytes_with_rng(HEADER_HASH_SIZE, rng));
    BlockHeader::from(header)
}

/// Very simple function to generate random sequence of bytes of given length.
fn random_bytes_with_rng(arg: usize, rng: &mut StdRng) -> Vec<u8> {
    let mut buffer = vec![0; arg];
    rng.fill_bytes(&mut buffer);
    buffer
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_headers_tree() {
        let tree = generate_header_tree(5, 42, Ratio(1, 2));
        assert_eq!(tree.depth(), 5);
        check_nodes(&tree);
    }

    // HELPERS
    fn check_nodes(node: &Tree<BlockHeader>) {
        assert_eq!(
            node.value.hash(),
            BlockHeader::from(node.value.header().clone()).hash()
        );
        for child in &node.children {
            assert_eq!(child.value.parent(), Some(node.value.hash()));
            check_nodes(child);
        }
    }
}
