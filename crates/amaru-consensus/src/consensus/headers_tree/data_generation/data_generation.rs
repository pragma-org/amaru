// Copyright 2025 PRAGMA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::consensus::headers_tree::arena::{find_best_tip, get_arena_active_nodes};
use crate::consensus::headers_tree::data_generation::TestHeader;
use crate::consensus::headers_tree::HeadersTree;
use crate::consensus::tip::Tip;
use amaru_kernel::peer::Peer;
use amaru_kernel::HEADER_HASH_SIZE;
use amaru_ouroboros_traits::IsHeader;
use indextree::{Arena, NodeId};
use pallas_crypto::hash::Hash;
use proptest::prelude::{any, RngCore, Strategy};
use proptest::prop_compose;
use rand::prelude::StdRng;
use rand::{Rng, SeedableRng};
use rand_distr::{Distribution, Exp};
use std::collections::BTreeMap;

/// Generate a chain of headers anchored at a given header.
///
/// The chain is generated by creating headers with random body hash, and linking
/// them to the previous header in the chain until the desired length is reached.
pub fn generate_headers_chain(length: usize) -> Vec<TestHeader> {
    let mut rng = StdRng::seed_from_u64(42);
    generate_headers(length, &mut rng)
}

/// Generate just one header
pub fn generate_header() -> TestHeader {
    generate_headers_chain(1)[0]
}

pub fn create_headers_tree(size: usize) -> (HeadersTree<TestHeader>, Vec<TestHeader>) {
    let headers = generate_headers_chain(size);
    let mut tree = HeadersTree::new(10, &headers.first().cloned());
    let mut tail = headers.clone();
    _ = tail.remove(0);
    _ = tree.insert_headers(&tail);
    (tree, headers)
}

pub fn initialize_with_peer(
    size: usize,
    peer: &Peer,
) -> (HeadersTree<TestHeader>, Vec<TestHeader>) {
    let (mut tree, headers) = create_headers_tree(size);
    let tip = headers.last().unwrap();
    tree.initialize_peer(peer, &tip.hash()).unwrap();
    (tree, headers)
}

pub fn make_header_with_parent(parent: &TestHeader) -> TestHeader {
    TestHeader {
        hash: random_hash(),
        slot: parent.slot + 1,
        parent: Some(parent.hash()),
    }
}

pub fn random_hash() -> Hash<HEADER_HASH_SIZE> {
    Hash::from(random_bytes(HEADER_HASH_SIZE).as_slice())
}

pub fn any_headers_tree(
    depth: usize,
    max_length: usize,
    peers_nb: usize,
) -> impl Strategy<Value=HeadersTree<TestHeader>> {
    (0..u64::MAX).prop_map(move |seed| generate_headers_tree(depth, max_length, peers_nb, seed))
}

/// Generate a headers tree of max depth 'depth' (also the size of the longest chain)
/// and random peers (named "1", "2", "3",...) pointing on some nodes of the tree
pub fn generate_headers_tree(
    depth: usize,
    max_length: usize,
    peers_nb: usize,
    seed: u64,
) -> HeadersTree<TestHeader> {
    let mut rng = StdRng::seed_from_u64(seed);
    let mut arena = generate_arena(depth, &mut rng);
    renumber_headers(&mut arena);

    let tip = find_best_tip(&arena).unwrap();
    let mut peers = generate_peers(&arena, peers_nb);

    // Set a peer at the tip of the best chain
    let best_peer: Option<Peer> = peers.keys().last().cloned();
    peers.insert(best_peer.clone().unwrap(), tip);

    HeadersTree::create(arena, max_length, peers, tip, best_peer)
}

// Data generator for random TestHeaders
prop_compose! {
    pub fn any_test_header()(
        slot in 0..1000000u64,
        parent in any::<[u8; 32]>(),
        body in any::<[u8; 32]>(),
    )
        -> TestHeader {
        TestHeader {
            hash: body.into(),
            slot,
            parent: Some(parent.into()),
        }
    }
}

/// IMPLEMENTATION

/// Generate a chain of headers anchored at a given header.
///
/// The chain is generated by creating headers with random body hash, and linking
/// them to the previous header in the chain until the desired length is reached.
fn generate_headers(length: usize, rng: &mut StdRng) -> Vec<TestHeader> {
    let mut headers: Vec<TestHeader> = Vec::new();
    let mut parent: Option<TestHeader> = None;
    // simulate block distribution on mainnet as an exponential distribution with
    // parameter Î» = 1/20
    let poi = Exp::new(0.05).unwrap();
    for _ in 0..length {
        let next_slot: f32 = poi.sample(rng);
        let header = TestHeader {
            hash: Hash::from(random_bytes(HEADER_HASH_SIZE).as_slice()),
            slot: parent.map_or(0, |h| h.slot()) + (next_slot.floor() as u64),
            parent: parent.map(|h| h.hash()),
        };
        headers.push(header);
        parent = Some(header);
    }
    headers
}

/// Once the arena is generated rename the block numbers and slots in the order of their creation
/// to help diagnose the tests.
fn renumber_headers(arena: &mut Arena<Tip<TestHeader>>) {
    for (count, n) in arena.iter_mut().enumerate() {
        if let Tip::Hdr(header) = n.get_mut() {
            header.slot = count as u64 + 1;
        };
    }
}

/// Generate an arbitrary list of peers named "1", "2", "3",... pointing at existing nodes in the arena.
fn generate_peers(arena: &Arena<Tip<TestHeader>>, nb: usize) -> BTreeMap<Peer, NodeId> {
    let mut rng = rand::rng();
    let node_ids: Vec<_> = get_arena_active_nodes(arena)
        .map(|n| arena.get_node_id(n).unwrap())
        .collect();
    let mut result = BTreeMap::new();
    for n in 1..(nb + 1) {
        let node_id = node_ids[rng.random_range(0..node_ids.len())];
        result.insert(Peer::new(&format!("{n}")), node_id);
    }
    result
}

/// Generate an arena of fake headers with a limited depth
fn generate_arena(depth: usize, rng: &mut StdRng) -> Arena<Tip<TestHeader>> {
    let mut arena = Arena::with_capacity(depth * depth);
    let root = generate_headers(1, rng)[0];
    let root_node_id = arena.new_node(Tip::Hdr(root));
    generate_blocktree_in_arena(&mut arena, rng, depth - 1, root_node_id);
    arena
}

/// Generate an arena of fake headers with a limited depth
fn generate_blocktree_in_arena(
    arena: &mut Arena<Tip<TestHeader>>,
    rng: &mut StdRng,
    depth: usize,
    parent_node_id: NodeId,
) {
    let mut spine = generate_headers(depth, rng);
    let mut current_size = 0;
    let mut parent_node_id = parent_node_id;
    for n in spine.iter_mut() {
        n.parent = arena
            .get(parent_node_id)
            .unwrap()
            .get()
            .to_header()
            .map(|h| h.hash());
        let tip = arena.new_node(Tip::Hdr(*n));
        parent_node_id.append(tip, arena);
        parent_node_id = tip;
        current_size += 1;
        let other_branch_depth = rng.random_range(0..(depth - current_size + 1));
        if other_branch_depth > 0 {
            generate_blocktree_in_arena(arena, rng, other_branch_depth, tip);
        }
    }
}

/// Very simple function to generate random sequence of bytes of given length.
fn random_bytes(arg: usize) -> Vec<u8> {
    let mut rng = StdRng::from_os_rng();
    let mut buffer = vec![0; arg];
    rng.fill_bytes(&mut buffer);
    buffer
}
