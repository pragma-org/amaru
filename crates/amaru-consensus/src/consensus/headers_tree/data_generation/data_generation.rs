// Copyright 2025 PRAGMA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! This module provides data types and functions to generate data suited to testing the `HeadersTree`:
//!
//!  - `Tree<H>` is used to eventually hold a tree of `TestHeader`s.
//!  - `generate_test_header_tree` generates such a tree by arbitrarily grafting subtrees on a chain
//!    of size `depth`.
//!
//!

use crate::consensus::headers_tree::HeadersTree;
use crate::consensus::headers_tree::data_generation::{Ratio, TestHeader};
use crate::consensus::headers_tree::tree::Tree;
use amaru_kernel::HEADER_HASH_SIZE;
use amaru_kernel::peer::Peer;
use amaru_kernel::tests::random_hash;
use amaru_ouroboros_traits::in_memory_consensus_store::InMemConsensusStore;
use amaru_ouroboros_traits::{ChainStore, IsHeader};
use pallas_crypto::hash::Hash;
use proptest::prelude::Strategy;
use rand::prelude::StdRng;
use rand::{Rng, RngCore, SeedableRng};
use rand_distr::{Distribution, Exp};
use std::sync::Arc;

impl Tree<TestHeader> {
    /// This function is used to give incrementing slot numbers to `TestHeader`s and help test failures
    /// diagnosis
    fn renumber_slots(&mut self, start: u64) {
        self.value.slot = start;
        for (i, child) in self.children.iter_mut().enumerate() {
            child.renumber_slots(start + ((i + 1) as u64));
            child.value.parent = Some(self.value.hash);
        }
    }
}

/// Return a `proptest` Strategy producing a random `Tree<TestHeader>` of a given depth
pub fn any_tree_of_headers(
    depth: usize,
    branching_ratio: Ratio,
) -> impl Strategy<Value = Tree<TestHeader>> {
    (0..u64::MAX).prop_map(move |seed| generate_test_header_tree(depth, seed, branching_ratio))
}

/// Generate a tree of headers of a given depth.
/// A seed is used to control the random generation of subtrees on top of a spine of length `depth`.
pub fn generate_test_header_tree(
    depth: usize,
    seed: u64,
    branching_ratio: Ratio,
) -> Tree<TestHeader> {
    let mut rng = StdRng::seed_from_u64(seed);

    let root = generate_test_header(&mut rng);
    let mut root_tree = Tree::make_leaf(&root);
    generate_test_header_subtree(&mut rng, &mut root_tree, depth - 1, branching_ratio);
    // renumber slots to make debugging easier
    root_tree.renumber_slots(1);
    root_tree
}

/// Given a random generator and a tree:
///
///  - Generate a spine (a chain of `TestHeaders`).
///  - Randomly add subtrees to nodes of that spine.
///  - Graft the spine on the last child of `tree`.
///
/// The depth is used so that the subtrees added to the spine don't have a higher depth than the spine.
/// The branching ratio is used to control how often subtrees are added to the spine.
///
fn generate_test_header_subtree(
    rng: &mut StdRng,
    tree: &mut Tree<TestHeader>,
    depth: usize,
    branching_ratio: Ratio,
) -> Vec<TestHeader> {
    let mut spine = generate_headers(depth, rng);
    let mut current = tree;
    let mut current_size = 0;
    for n in spine.iter_mut() {
        current.add_child(n);
        n.parent = Some(current.value.hash());
        current = current.get_last_child_mut().unwrap();
        current_size += 1;
        let other_branch_depth = rng.random_range(
            0..((depth - current_size) * branching_ratio.0 as usize / branching_ratio.1 as usize
                + 1),
        );
        if other_branch_depth > 0 {
            generate_test_header_subtree(rng, current, other_branch_depth, branching_ratio);
        }
    }
    spine
}

/// Generate a chain of headers anchored at a given header.
///
/// The chain is generated by creating headers with random body hash, and linking
/// them to the previous header in the chain until the desired length is reached.
pub fn generate_headers_chain(length: usize) -> Vec<TestHeader> {
    let mut rng = StdRng::seed_from_u64(42);
    generate_headers(length, &mut rng)
}

/// Generate just one header
pub fn generate_header() -> TestHeader {
    generate_headers_chain(1)[0]
}

/// Generate a random `HeadersTree` initialized with a single chain of `TestHeader`s
pub fn create_headers_tree_with_store(
    store: Arc<dyn ChainStore<TestHeader>>,
    size: usize,
) -> HeadersTree<TestHeader> {
    let headers = generate_headers_chain(size);
    for header in &headers {
        store.store_header(header).unwrap();
    }
    store.set_anchor_hash(&headers[0].hash()).unwrap();
    store
        .set_best_chain_hash(&headers[headers.len() - 1].hash())
        .unwrap();
    HeadersTree::new(store.clone(), 10)
}

/// Generate a random `HeadersTree` initialized with a single chain of `TestHeader`s
pub fn create_headers_tree(size: usize) -> HeadersTree<TestHeader> {
    create_headers_tree_with_store(Arc::new(InMemConsensusStore::new()), size)
}

/// Generate a `HeadersTree` with one chain and a peer at the tip.
pub fn initialize_with_peer(size: usize, peer: &Peer) -> HeadersTree<TestHeader> {
    initialize_with_store_and_peer(Arc::new(InMemConsensusStore::new()), size, peer)
}

/// Generate a `HeadersTree` with one chain and a peer at the tip.
pub fn initialize_with_store_and_peer(
    store: Arc<dyn ChainStore<TestHeader>>,
    size: usize,
    peer: &Peer,
) -> HeadersTree<TestHeader> {
    let mut tree = create_headers_tree_with_store(store, size);
    tree.initialize_peer(peer, &tree.best_chain_tip().hash())
        .unwrap();
    tree
}

/// Generate a random `TestHeader`, child of the `parent` one
/// and store it in the provided store.
pub fn store_header_with_parent(
    store: Arc<dyn ChainStore<TestHeader>>,
    parent: &TestHeader,
) -> TestHeader {
    let header = TestHeader {
        hash: random_hash(),
        slot: parent.slot + 1,
        parent: Some(parent.hash()),
    };
    store.store_header(&header).unwrap();
    header
}

// IMPLEMENTATION

/// Generate a chain of headers anchored at a given header.
///
/// The chain is generated by creating headers with random body hash, and linking
/// them to the previous header in the chain until the desired length is reached.
fn generate_headers(length: usize, rng: &mut StdRng) -> Vec<TestHeader> {
    let mut headers: Vec<TestHeader> = Vec::new();
    let mut parent: Option<TestHeader> = None;
    // simulate block distribution on mainnet as an exponential distribution with parameter Î» = 1/20
    let poi = Exp::new(0.05).unwrap();
    let next_slot: f32 = poi.sample(rng);
    for _ in 0..length {
        let mut header = generate_test_header(rng);
        header.slot = parent.map_or(0, |h| h.slot()) + (next_slot.floor() as u64);
        header.parent = parent.map(|h| h.hash());
        headers.push(header);
        parent = Some(header);
    }
    headers
}

/// Generate a single `TestHeader` but using the provided random generator.
fn generate_test_header(rng: &mut StdRng) -> TestHeader {
    TestHeader {
        hash: Hash::from(random_bytes_with_rng(HEADER_HASH_SIZE, rng).as_slice()),
        slot: 0,
        parent: None,
    }
}

/// Very simple function to generate random sequence of bytes of given length.
fn random_bytes_with_rng(arg: usize, rng: &mut StdRng) -> Vec<u8> {
    let mut buffer = vec![0; arg];
    rng.fill_bytes(&mut buffer);
    buffer
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_test_headers_tree() {
        let tree = generate_test_header_tree(5, 42, Ratio(1, 2));
        assert_eq!(tree.depth(), 5);
    }
}
